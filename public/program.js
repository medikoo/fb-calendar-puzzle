// This file was generated by modules-webmake (modules for web) project
// see: https://github.com/medikoo/modules-webmake

(function (modules) {
	var getModule, getRequire, require;
	getModule = (function (wrap) {
		return function (scope, tree, path, fullpath) {
			var name, dir, exports = {}, module = { exports: exports }, fn;
			path = path.split('/');
			name = path.pop();
			while ((dir = path.shift())) {
				if (dir === '..') {
					scope = tree.pop();
				} else if (dir !== '.') {
					tree.push(scope);
					scope = scope[dir];
				}
			}
			if (scope[name + '.js']) {
				name += '.js';
			}
			if (typeof scope[name] === 'object') {
				tree.push(scope);
				scope = scope[name];
				name = 'index.js';
			}
			fn = scope[name];
			if (!fn) {
				throw new Error("Could not find module '" + fullpath + "'");
			}
			scope[name] = wrap(module);
			fn.call(exports, exports, module, getRequire(scope, tree));
			return module.exports;
		};
	})(function (cmodule) {
		return function (ignore, module) {
			module.exports = cmodule.exports;
		};
	});
	require = function (scope, tree, fullpath) {
		var name, path = fullpath, t = fullpath.charAt(0);
		if (t === '/') {
			path = path.slice(1);
			scope = modules['/']; tree = [];
		} else if (t !== '.') {
			name = path.split('/', 1)[0];
			scope = modules[name]; tree = [];
			path = path.slice(name.length + 1) || scope[':mainpath:'];
		}
		return getModule(scope, tree, path, fullpath);
	};
	getRequire = function (scope, tree) {
		return function (path) {
			return require(scope, [].concat(tree), path);
		};
	};
	return getRequire(modules, []);
})
({
	"facebook-puzzle": {
		"lib": {
			"build": {
				"day-events.js": function (exports, module, require) {
					'use strict';

					// Builds event objects for events view

					var layOutDay = require('../lay-out-day')

					  , width = 600
					  , padding = 10;

					module.exports = function (events) {
						var el, i, event, next, html;

						el = document.createElement('ul');
						el.className = 'events';
						events = layOutDay(events);

						html = '';
						for (i = 0; event = events[i]; ++i) {
							next = events[i + 1];
							html += '<li style="' +
								'top: ' + event.top + 'px; ' +
								'left: ' + (padding + event.left) + 'px; ' +
								'width: ' + event.width + 'px; ' +
								'height: ' + (event.end - event.start) + 'px; ' +
								'"><div class="deco"><p>Event #' + event.id + '</p></div></li>';
						}
						el.innerHTML = html;
						return el;
					};
				},
				"day-legend.js": function (exports, module, require) {
					'use strict';

					// Builds time legend for events view

					module.exports = function (shour, ehour) {
						var el, hour, isPM, html;

						el = document.createElement('ul');
						el.className = 'legend';
						html = '';
						while (shour <= ehour) {
							hour = shour%12;
							if (hour != shour) {
								isPM = true;
							}
							if (!hour) {
								hour = 12;
							}
							html += '<li><span class="hour">' + hour + ':00</span> ' +
								(isPM ? 'P' : 'A') + 'M</li>';
							if ((shour + 0.5) <= ehour) {
								html += '<li>' + hour + ':30</li>';
							}
							++shour;
						}
						el.innerHTML = html;
						return el;
					};
				},
				"day.js": function (exports, module, require) {
					'use strict';

					// Builds single day events view

					var buildLegend = require('./day-legend')
					  , buildEvents = require('./day-events')

					module.exports = function (container, events) {
						container.appendChild(buildLegend(9, 21));
						container.appendChild(buildEvents(events));
					};
				}
			},
			"lay-out-day.js": function (exports, module, require) {
				'use strict';

				// Calculates events layout for single day

				var keys  = Object.keys
				  , round = Math.round

				  , numberCompare, startCompare, collidingCompare
				  , copy, concurrent, setWidth, equalLeft
				  , width;

				width = 600;
				copy = function (arr) {
					return arr.slice(0);
				};
				numberCompare = function (a, b) {
					return a - b;
				};
				startCompare = function (a, b) {
					return numberCompare(a.start, b.start);
				};
				concurrent = function (event) {
					return event.end > this.start;
				};
				collidingCompare = function (a, b) {
					return numberCompare(b.colliding.length, a.colliding.length);
				};
				setWidth = function (event) {
					return this.width = event.width;
				};
				equalLeft = function (event) {
					return event.left == this;
				};

				module.exports = function (events) {
					var map, current, mapKeys, input;

					// Do not alter order of input array
					input = events;
					events = copy(events);

					// Build events map
					current = []; map = { 0: [] };
					events.sort(startCompare).forEach(function (event) {
						current = current.filter(concurrent, event);
						current.push(event);
						map[event.start] = copy(current);
					});

					// For each event find highest number of events that it collides with
					mapKeys = keys(map).sort(numberCompare);
					events.forEach(function (event) {
						event.colliding = [];
						while (mapKeys[0] < event.start) {
							mapKeys.shift();
						}
						mapKeys.some(function (key) {
							if (key >= event.end) {
								return true;
							}
							if (event.colliding.length < map[key].length) {
								event.colliding = map[key];
							}
						});
					});

					// Set width of each event object (based on maximum colliding events count)
					events.sort(collidingCompare).forEach(function (event) {
						if (!event.colliding.some(setWidth, event)) {
							event.width = round(width/event.colliding.length);
						}
						// We no longer need collision map
						delete event.colliding;
					});

					// Calculate left & top position for each event object
					current = [];
					events.sort(startCompare).forEach(function (event) {
						var left;
						current = current.filter(concurrent, event);

						// top
						event.top = event.start;

						// left
						left = 0;
						while (current.some(equalLeft, left)) {
							left += event.width;
						}
						event.left = left;
						current.push(event);
					});

					return input;
				};
			},
			"program.js": function (exports, module, require) {
				'use strict';

				// Initial program

				// Setup ES5 shims for older implementations
				require('./shim/keys');
				require('./shim/for-each');
				require('./shim/filter');
				require('./shim/some');

				// Expose build function
				window.LAYOUT = require('./build/day');
			},
			"shim": {
				"filter.js": function (exports, module, require) {
					'use strict';

					if (!Array.prototype.filter) {
						Array.prototype.filter = function (fun, thisp) {
							var i, length, result;

							if (typeof fun !== 'function') {
								throw new TypeError();
							}

							i = 0;
							length = this.length;
							result = [];
							while (i < length) {
								if (this.hasOwnProperty(i)) {
									if (fun.call(thisp, this[i], i, this)) {
										result.push(this[i]);
									}
								}
								++i;
							}
							return result;
						};
					}
				},
				"for-each.js": function (exports, module, require) {
					'use strict';

					if (!Array.prototype.forEach) {
						Array.prototype.forEach = function (fun, thisp) {
							var i, length;

							if (typeof fun !== 'function') {
								throw new TypeError();
							}

							i = 0;
							length = this.length;
							while (i < length) {
								if (this.hasOwnProperty(i)) {
									fun.call(thisp, this[i], i, this);
								}
								++i;
							}
						};
					}
				},
				"keys.js": function (exports, module, require) {
					'use strict';

					if (!Object.keys) {
						// Basic and not perfectly safe implementation
						// (safe enough for this task)

						Object.keys = function (obj) {
							var keys = [];
							for (var name in obj) {
								if (obj.hasOwnProperty(name)) {
									keys.push(name);
								}
							}
							return keys;
						};
					}
				},
				"some.js": function (exports, module, require) {
					'use strict';

					if (!Array.prototype.some) {
						Array.prototype.some = function (fun, thisp) {
							var i, length;

							if (typeof fun !== 'function') {
								throw new TypeError();
							}

							i = 0;
							length = this.length;
							while (i < length) {
								if (this.hasOwnProperty(i)) {
									if (fun.call(thisp, this[i], i, this)) {
										return true;
									}
								}
								++i;
							}
							return false;
						};
					}
				}
			}
		}
	}
})
("facebook-puzzle/lib/program");
